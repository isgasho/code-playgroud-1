## 概念

##### Mysql 的三层逻辑架构 
![](https://upload-images.jianshu.io/upload_images/8573331-0bc0c30bd6d1f28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
1. 第一层负责连接管理、授权认证、安全等等。
2. 第二层是Mysql的核心服务功能 查询解析、分析、优化、缓存及所有内置函数，还有存储过程，触发器，视图等等。
3. 第三层主要是存储引擎。 

##### 事务
一个事务处理系统必须具有该四项特征ACID：
- 原子性（atomicity）：一个事务是最小工作单元，要么全部执行要么回滚失败。
- 一致性（consistency）：确保数据从一个状态转移成另一个状态。比如转账，我转你100，你增加100，我减少。
- 隔离性（isolation）：一个事务所做的修改在提交之前，其他事务不可见。事务隔离是依靠回滚日志实现的，即MVVC，一条记录会记录多次提交的回滚日志undolog，也会记录transectionId。系统会判断删除回滚日志。
  1. READ UNCOMMITTED（读未提交ru）：事务未提交，其他事务都是可见的。脏写脏读
  2. READ COMMITTED（读提交rc）：大部分数据库隔离级别，Mysql是rr。一个事务提交之后，所做的修改才会被其他事务可见。解决了脏读，也叫不可重复读 重复读数据会不一致，也就是说在A事务提交后，B事务中能查看到修改。
  3. REPEATABLE READ（可重复读rr）：从事务开始到结束，读取的记录是一致的，也就是说不管其他事务是否提交，都不影响该事务，该事务还是最初读取到的数据。解决了脏读和不可重复读，但没法解决幻读，指某个事务在读取某个范围记录时，另一个事务又在范围内插入了新纪录。之前的事务再次读取该范围的记录时，会产生幻行（强调范围查询）。可通过间隙锁策略防止幻读，间隙锁锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行插入。
  4. SERIALIZABLE（串行化）：是最高的隔离级别，强制了事务串行执行。简单说，会在读取的每一行都加锁，所以并发大会导致超时和锁争用的问题。
- 持久性（durability）：一旦提交，修改永久保存到数据库。


##### 三范式
1. 字段是最小的的单元不可再分
2. 满足第一范式，表中的字段必须完全依赖于全部主键而非部分主键（数据依赖主键）
3. 满足第二范式，非主键外的所有字段必须互不依赖（数据没有冗余）

> 范式与反范式的优缺点？
范式化：没有数据冗余表通常更少，可以更好的放在内存里，更新更快。缺点就是通常需要关连表，代价昂贵些。写多读少优
反范式化：可以有效避免连表，缺点表数据大，不易维护。
基本上都会灵活混用范式和反范式，可以通过冗余数据来减少连表操作。

##### 计数器表
通常在记录用户的朋友数，文件下载次数会创建一个计数器表。使用独立的表可以避免缓存失效。

如果有一个计数器表，该表只有一行数据，用来记录网站的点击次数。

```sql
CREATE TABLE hit_counter (
    cnt int unsigned not null
) ENGINE=InnoDB
```

这样会有一个问题，当并发上来时，由于这条记录又一个全局互斥锁。这是的插入事物串行执行。为了增加写入性能，可以把数据保存在多行中，每次随机选择一行更新。这样该表修改为

```sql
CREATE TABLE hit_counter (
    slot tinyint unsigned not null primary key,
    cnt int unsigned not null
) ENGINE=InnoDB
```

更新和获取将变为

```sql
UPDATE hit_counter SET cnt = cnt + 1 WHERE slot = RAND() * 100;
SELECT SUM(cnt) FROM hit_counter;
```

> 为了提高查询速度，经常需要创建额外的索引，增加冗余列，甚至创建缓存表和汇总表。虽然增加了写的负担，也需要额外维护，但这都是常用技巧。

##### MVCC
mysql的MVCC（多版本并发控制）是通过保存数据在某个时间点的快照实现的。通过存储额外的隐形列来避免大多数读操作加锁，空间换时间。MVCC只在rr和rc的隔离级别下工作。

##### InnoDB 和 MyISAM
补充：

## Mysql的索引

##### 常见索引类型
- B+ 树索引：在数据库中的高度一般为 2~4 层。也就是查一条记录最多需要 2~4次IO。优势在于排序查找和范围查找
- 全文索引
- 哈希索引
- 倒排索引：radix tree 实现。

##### 聚簇索引
聚集索引的存储是逻辑连续的，页通过双向链表链接，页按照主键的顺序拍下。每页的记录也是通过双向链表维护的。
聚簇索引保存了BTREE索引和数据行，数据行存储在叶子节点中，节点只包含索引列。一个表只存在一个聚簇索引。

##### 二级索引
二级索引的叶子节点存储的是主键值。查询索引值之外的值需要回表。

##### 覆盖索引
即查询的二级索引全包含要查询的字段，不需要回表到聚簇索引查询其他字段，可以减少大量的IO操作。
explain 列的 Extra 值为 Using index 带吧优化器进行了覆盖索引操作。

##### 利用索引排序
尽可能让索引既满足排序，有满足查找行是最好的。索引的列顺序和order by子句顺序完全一致，并且所有列的排序方向都一样，才能用索引对结果排序。
如果查询需要关联多张表，则只有order by子句引用的字段全部为第一个表时，才能用索引排序

##### 联合索引
表示对表上的多个列进行索引。键值是依据这些列排好序的。

##### 索引的查询类型
1. 全值匹配
2. 匹配最左前缀
3. 匹配列前缀
4. 匹配范围值
5. 精确匹配某一列并范围匹配另外一列
6. 只访问索引的查询  

限制：
1. 如果不是按照索引的最左列开始查找，则无法使用索引
2. 不能跳过索引中的列
3. 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

##### Cardinality 基数
可以通过 SHOW INDEX 查看，表示索引中不重复记录数量的预估值。要保证 Cardinality / table_rows 的值越大表示字段的区分度越高。
优化器会根据 Cardinality 的值来判断是否使用该索引。从性能角度考虑，该值不是实时更新的。
更新策略，主要是对多节点采样，所以每次取值可能不一样:  
- 表中 1/16 的数据已发生过变化
- stat_modified_counter > 2000000000（表示发生变化的次数，应对对某一行数据的更新操作）

##### 优化器选择不使用索引的情况
在有些情况下，执行EXPLAIN命令分析的时候，会发现优化器没有选择索引去查找数据。而是通过扫描聚集索引，也就是全表扫描。这种情况多发生范围查找，JOIN连表等操作。

##### explain 字段说明与解析 列举常见的类型
1. id                select关键字对应的唯一id
2. select_type       查询类型（SIMPLE 不包含union和子查询/PRIMARY/SUBQUERY...）
3. table             表名
4. partitions        分区信息
5. type              访问方法（system/const 主键或者唯一二级索引等值匹配/ref 普通二级索引等值匹配/range 使用索引获取范围区间记录/index 需要扫描全部索引记录/ALL 全表扫描）
6. possible_keys     可能用到的索引
7. key               实际用到的索引
8. key_len           实际用到的索引长度
9. ref               索引使用等值匹配查询(用来描述type类型为等值查询的信息) const
10. rows             预估扫描的行数
11. filtered         经过搜索条件过滤后剩余记录条数的百分比
12. Extra            Using index（覆盖索引场景，与type为index不同）/Using where（全表扫描使用可where）/ Using filesort （表示需要额外的一次排序才能完成查询）

##### Multi-Range Read 优化
MRR优化的目的是为了减少磁盘的随机访问，并将随机访问转化为较为顺序的数据访问，对 IO-bound类型的查询带来比较大的提升，适用于 range，ref，eq_ref类型的查询。mysql 5.6 开始支持

##### Index Condition Pushdown (ICP 索引下推)优化
是一种根据索引进行查询的优化方式，5.6版本之前不支持。
- 支持前：之前的查询方式是，当进行索引查询时，首先根据索引来查找记录，然后再根据WHERE条件过滤记录。
- 支持后：在去除索引的同事，判断是否可以进行 WHERE 条件的过滤，也就是将WHERE的部分过滤操作放到了存储引擎层。可以大大减少上层SQL层对记录的索取，从而提升整体性能。

ICP 优化支持 range，ref，eq_ref，ref_or_null类型的查询。当优化器选择 ICP 时，可以在explai的Extra看到 Using index condition。

ICP 是如何优化的？



## Mysql中的锁
##### Mysql 的锁
不错的文章 [https://mp.weixin.qq.com/s/rLdHuwEb7gKjgpbsh1ioSA]()

- 读写锁（读锁和写锁，也叫共享锁和排他锁）
- 锁粒度
  1. 表锁：开销比较小，但是并发很弱。写操作会阻塞读写操作，读锁不互相阻塞。MyIsam就是表锁。一般ALTER TABLE会锁表。
  2. 行级锁：可以最大成都支持并发，同时也会带来锁开销，在存储引擎中实现。


## 数据库优化思路
1. 查询优化
2. 索引优化
3. 库表结构优化
  
## 优化limit分页操作
一个比较常见且头特的问题，在翻页的偏移量比较大的时候，代价非常高。


## 参考资料
1. mysql 事物隔离级别？[SQL 事务隔离实用指南](https://juejin.im/post/59b7ce03f265da0672281fcc?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)
