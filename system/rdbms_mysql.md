## 概念

##### Mysql 的三层逻辑架构 
![](https://upload-images.jianshu.io/upload_images/8573331-0bc0c30bd6d1f28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
1. 第一层负责连接管理、授权认证、安全等等。
2. 第二层是Mysql的核心服务功能 查询解析、分析、优化、缓存及所有内置函数，还有存储过程，触发器，视图等等。
3. 第三层主要是存储引擎。 

##### 事务
一个事务处理系统必须具有该四项特征ACID：
- 原子性（atomicity）：一个事务是最小工作单元，要么全部执行要么回滚失败。
- 一致性（consistency）：确保数据从一个状态转移成另一个状态。比如转账，我转你100，你增加100，我减少。
- 隔离性（isolation）：一个事务所做的修改在提交之前，其他事务不可见。事务隔离是依靠回滚日志实现的，即MVVC，一条记录会记录多次提交的回滚日志undolog，也会记录transectionId。系统会判断删除回滚日志。使用`SELECT @@tx_isolation`查看隔离级别，Mysql 末日RR级别。
  1. READ UNCOMMITTED（读未提交ru）：事务未提交，其他事务都是可见的。脏写脏读
  2. READ COMMITTED（读提交rc）：大部分数据库隔离级别，Mysql是rr。一个事务提交之后，所做的修改才会被其他事务可见。解决了脏读，也叫不可重复读 重复读数据会不一致，也就是说在A事务提交后，B事务中能查看到修改。
  3. REPEATABLE READ（可重复读rr）：从事务开始到结束，读取的记录是一致的，也就是说不管其他事务是否提交，都不影响该事务，该事务还是最初读取到的数据。解决了脏读和不可重复读，但没法解决幻读，指某个事务在读取某个范围记录时，另一个事务又在范围内插入了新纪录。之前的事务再次读取该范围的记录时，会产生幻行（强调范围查询）。可通过间隙锁策略防止幻读，间隙锁锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行插入。
  4. SERIALIZABLE（串行化）：是最高的隔离级别，强制了事务串行执行。简单说，会在读取的每一行都加锁，所以并发大会导致超时和锁争用的问题。
- 持久性（durability）：一旦提交，修改永久保存到数据库。


##### 三范式
1. 字段是最小的的单元不可再分
2. 满足第一范式，表中的字段必须完全依赖于全部主键而非部分主键（数据依赖主键）
3. 满足第二范式，非主键外的所有字段必须互不依赖（数据没有冗余）

> 范式与反范式的优缺点？
范式化：没有数据冗余表通常更少，可以更好的放在内存里，更新更快。缺点就是通常需要关连表，代价昂贵些。写多读少优
反范式化：可以有效避免连表，缺点表数据大，不易维护。
基本上都会灵活混用范式和反范式，可以通过冗余数据来减少连表操作。

##### 计数器表
通常在记录用户的朋友数，文件下载次数会创建一个计数器表。使用独立的表可以避免缓存失效。

如果有一个计数器表，该表只有一行数据，用来记录网站的点击次数。

```sql
CREATE TABLE hit_counter (
    cnt int unsigned not null
) ENGINE=InnoDB
```

这样会有一个问题，当并发上来时，由于这条记录又一个全局互斥锁。这是的插入事物串行执行。为了增加写入性能，可以把数据保存在多行中，每次随机选择一行更新。这样该表修改为

```sql
CREATE TABLE hit_counter (
    slot tinyint unsigned not null primary key,
    cnt int unsigned not null
) ENGINE=InnoDB
```

更新和获取将变为

```sql
UPDATE hit_counter SET cnt = cnt + 1 WHERE slot = RAND() * 100;
SELECT SUM(cnt) FROM hit_counter;
```

> 为了提高查询速度，经常需要创建额外的索引，增加冗余列，甚至创建缓存表和汇总表。虽然增加了写的负担，也需要额外维护，但这都是常用技巧。

##### MVCC
mysql的MVCC（多版本并发控制）是通过保存数据在某个时间点的快照实现的。通过存储额外的隐形列来避免大多数读操作加锁，空间换时间。MVCC只在rr和rc的隔离级别下工作。

##### InnoDB 和 MyISAM
补充：

## Mysql的索引

##### 常见索引类型
- B+ 树索引：在数据库中的高度一般为 2~4 层。也就是查一条记录最多需要 2~4次IO。优势在于排序查找和范围查找
- 全文索引：innodb 在 1.2.x版本开始支持全文索引，但是限制比较多不建议使用，之前需要使用MyIsam引擎。
- 哈希索引：自适应哈希索引才有哈希表实现。对于kv型查询比较友好，对于范围查询排序类比较吃力。
- 倒排索引：全文检索通常使用倒排索引实现，而倒排主要使用 radix tree 实现。

##### 聚簇索引
聚集索引的存储是逻辑连续的，页通过双向链表链接，页按照主键的顺序拍下。每页的记录也是通过双向链表维护的。
聚簇索引保存了BTREE索引和数据行，数据行存储在叶子节点中，节点只包含索引列。一个表只存在一个聚簇索引。

##### 二级索引
二级索引的叶子节点存储的是主键值。查询索引值之外的值需要回表。

##### 覆盖索引
即查询的二级索引全包含要查询的字段，不需要回表到聚簇索引查询其他字段，可以减少大量的IO操作。
explain 列的 Extra 值为 Using index 带吧优化器进行了覆盖索引操作。

##### 利用索引排序
尽可能让索引既满足排序，有满足查找行是最好的。索引的列顺序和order by子句顺序完全一致，并且所有列的排序方向都一样，才能用索引对结果排序。
如果查询需要关联多张表，则只有order by子句引用的字段全部为第一个表时，才能用索引排序

##### 联合索引
表示对表上的多个列进行索引。键值是依据这些列排好序的。

##### 索引的查询类型
1. 全值匹配
2. 匹配最左前缀
3. 匹配列前缀
4. 匹配范围值
5. 精确匹配某一列并范围匹配另外一列
6. 只访问索引的查询  

限制：
1. 如果不是按照索引的最左列开始查找，则无法使用索引
2. 不能跳过索引中的列
3. 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

##### Cardinality 基数
可以通过 SHOW INDEX 查看，表示索引中不重复记录数量的预估值。要保证 Cardinality / table_rows 的值越大表示字段的区分度越高。
优化器会根据 Cardinality 的值来判断是否使用该索引。从性能角度考虑，该值不是实时更新的。
更新策略，主要是对多节点采样，所以每次取值可能不一样:  
- 表中 1/16 的数据已发生过变化
- stat_modified_counter > 2000000000（表示发生变化的次数，应对对某一行数据的更新操作）

##### 优化器选择不使用索引的情况
在有些情况下，执行EXPLAIN命令分析的时候，会发现优化器没有选择索引去查找数据。而是通过扫描聚集索引，也就是全表扫描。这种情况多发生范围查找，JOIN连表等操作。

##### explain 字段说明与解析 列举常见的类型
1. id                select关键字对应的唯一id
2. select_type       查询类型（SIMPLE 不包含union和子查询/PRIMARY/SUBQUERY...）
3. table             表名
4. partitions        分区信息
5. type              访问方法（system/const 主键或者唯一二级索引等值匹配/ref 普通二级索引等值匹配/range 使用索引获取范围区间记录/index 需要扫描全部索引记录/ALL 全表扫描）
6. possible_keys     可能用到的索引
7. key               实际用到的索引
8. key_len           实际用到的索引长度
9. ref               索引使用等值匹配查询(用来描述type类型为等值查询的信息) const
10. rows             预估扫描的行数
11. filtered         经过搜索条件过滤后剩余记录条数的百分比
12. Extra            Using index（覆盖索引场景，与type为index不同）/Using where（全表扫描使用可where）/ Using filesort （表示需要额外的一次排序才能完成查询）/ Using temporary （使用临时表保存结构）

##### Multi-Range Read 优化
MRR优化的目的是为了减少磁盘的随机访问，并将随机访问转化为较为顺序的数据访问，对 IO-bound类型的查询带来比较大的提升，
除了在Extra 看到Using index condition，还会有Using MRR选项，适用于 range，ref，eq_ref类型的查询。mysql 5.6 开始支持。

##### Index Condition Pushdown (ICP 索引下推)优化
是一种根据索引进行查询的优化方式，5.6版本之前不支持。
- 支持前：之前的查询方式是，当进行索引查询时，首先根据索引来查找记录，然后再根据WHERE条件过滤记录。
- 支持后：在去除索引的同事，判断是否可以进行 WHERE 条件的过滤，也就是将WHERE的部分过滤操作放到了存储引擎层。可以大大减少上层SQL层对记录的索取，从而提升整体性能。

ICP 优化支持 range，ref，eq_ref，ref_or_null类型的查询。当优化器选择 ICP 时，可以在explai的Extra看到 Using index condition。

ICP 是如何优化的？



## Mysql中的锁
##### Mysql 的锁
不错的文章 [https://mp.weixin.qq.com/s/rLdHuwEb7gKjgpbsh1ioSA](https://mp.weixin.qq.com/s/rLdHuwEb7gKjgpbsh1ioSA)
 
##### innodb 的两种标准行级锁
- 共享锁：即读锁，事务读数据不加锁。
- 排他锁：即写锁，允许当前事务更新数据，而其他事务等锁释放。

##### innodb 的表锁
意向锁为表级别的锁，也分为两种
- 意向共享锁：事务想获得一张表中某几行的共享锁
- 意向排他锁：事务想获得一张表中某几行的排他锁

##### 一致性非锁定读
一致性非锁定读通过 MVCC 的方式来读取数据。如果读取的行正在UPDATE或者DELETE，则该读取不等锁释放，而直接去读快照上面的数据。 

##### 一致性锁定读
主要有两种方法:
- SELECT ... FOR UPDATE  （排他锁）
- SELECT ... LOCK IN SHARE MODE （共享锁）

语句必须在一个事务中，当事务提交了，锁释放。

##### 锁的三种算法
- Record Lock：单行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，不包含记录本身。
- Next-Key Lock：Gap Lock + Record Lock。锁定范围，包含本身。如果存在唯一索引，则会降级为Record Lock。

Next-Key Lock示例：如果一个索引有10，11，13，20这几个值。那么被锁的区间为
```
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```
锁定索引所在的周边的区间。Gap Lock 是为了防止多个事务将记录插到同一范围内。
关闭间隙锁的方法，会破坏事务的隔离性，可能导致主从不一致：
- 隔离级别设置为 RC 模式
- innodb_locks_unsafe_for_binlog 设置为1

##### 幻读
幻读：是指在同一事务下，连续执行两次同样的sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行。
innodb使用Next-Key locking算法 解决幻读，对范围加锁，导致其他事务对该范围的插入都需要等待该间隙锁释放。

##### 脏读
脏页：在缓冲池中已经被修改的页，还没有刷到硬盘中。即内存和硬盘数据不一致。
脏读：指一个事务可以读到另外一个事务中未提交的数据，违背了数据库的隔离性。

##### 不可重复读
不可重复读：读取到了其他事务提交的数据。和脏读的区别在于，脏读读取到了其他事务未提交的数据，而不可重复读是读到了其他事务提交后的数据，违反了一致性原则。

在 innodb 中，使用 Next-Key locking算法 解决不可重复读的问题，在官方文档中，将不可重复读的问题定义未幻读问题，对于索引扫描，不仅锁住扫描到的索引，而且还锁住这些索引覆盖的范围，就避免了其他事务在该范围内插入数据而导致不可重复读的问题。

##### 丢失更新
 丢失更新：一个事务的更新操作会被另一个事务的更新操作锁覆盖，从而导致数据不一致。
数据库层面由于更新会加行锁，所以理论上不会有这个问题。注意业务上的问题。

## Mysql 中的事务
事务的四要素，上面已经讲过了。这里先跳过。

#### 实现
redo log：重做日志，用来保证事务的原子性和持久性。恢复提交事务修改的页操作。物理日志，记录页的物理修改操作。
undo log：保证食物的一致性。回滚到记录的某个特定版本。逻辑日志记录每行的修改。

##### redo

##### undo

## 数据库优化思路
1. 查询优化
2. 索引优化
3. 库表结构优化
  
## 优化limit分页操作
一个比较常见且头特的问题，在翻页的偏移量比较大的时候，代价非常高。


## 参考资料
1. mysql 事物隔离级别？[SQL 事务隔离实用指南](https://juejin.im/post/59b7ce03f265da0672281fcc?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)
